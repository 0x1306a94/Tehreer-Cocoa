//
// Copyright (C) 2019-2020 Muhammad Tayyab Akram
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

import CoreGraphics
import Foundation
import SheenFigure

/// A `ShapingResult` object is a container for the results of text shaping. It is generated by a
/// `ShapingEngine` object to provide the information related to characters, their glyphs, offsets,
/// and advances.
public class ShapingResult {
    let sfAlbum: SFAlbumRef

    private var string: String!
    private var sizeByEm: CGFloat = 0.0

    init() {
        sfAlbum = SFAlbumCreate()
    }

    deinit {
        SFAlbumRelease(sfAlbum)
    }

    /// The UTF-16 range in source string.
    public private(set) var codeUnitRange = Range(uncheckedBounds: (0, 0))

    /// A boolean value that indicates whether the shaped text segment flows backward.
    public private(set) var isBackward: Bool = false

    /// The index to the first character in source string.
    public var startIndex: String.Index {
        return string.characterIndex(forUTF16Index: codeUnitRange.lowerBound)
    }

    /// The index after the last character in source string.
    public var endIndex: String.Index {
        return string.characterIndex(forUTF16Index: codeUnitRange.upperBound)
    }

    var glyphCount: Int {
        return Int(SFAlbumGetGlyphCount(sfAlbum))
    }

    /// The collection of glyph IDs.
    public var glyphIDs: GlyphIDs {
        return GlyphIDs(self)
    }

    /// The collection of glyph offsets.
    public var glyphOffsets: GlyphOffsets {
        return GlyphOffsets(self)
    }

    /// The collection of glyph advances.
    public var glyphAdvances: GlyphAdvances {
        return GlyphAdvances(self)
    }

    /// A collection of indexes, mapping each shaped UTF-16 code unit in source string to
    /// corresponding glyph.
    ///
    /// The map is produced according to following rules.
    ///
    /// 1. If a single code unit translates into multiple glyphs, then it maps to the first glyph in
    ///    the sequence.
    /// 2. If multiple code units form a group, such as a grapheme, which in turn translates into
    ///    multiple glyphs, then each character maps to the first glyph in the sequence.
    /// 3. If nonconsecutive code units translate to a single glyph or ligature, then each
    ///    participating code unit, and all in-between characters, map to this glyph or ligature.
    public var clusterMap: ClusterMap {
        return ClusterMap(self)
    }

    /// Creates an array of caret edges.
    ///
    /// - Parameter caretStops: An array for caret stops of the UTF-16 code units represented by
    ///                         this object.
    /// - Returns: An array of caret edges.
    public func makeCaretEdges(caretStops: [Bool]?) -> [CGFloat] {
        if let caretStops = caretStops {
            precondition(caretStops.count >= codeUnitRange.count)
        }

        let edgeCount = codeUnitRange.count + 1
        let unsafeEdges = UnsafeMutablePointer<SFInt32>.allocate(capacity: edgeCount)
        defer { unsafeEdges.deallocate() }

        let loaded = caretStops?.withUnsafeBufferPointer { (buffer) -> Bool? in
            guard let baseAddress = buffer.baseAddress else {
                return nil
            }

            let unsafeStops = UnsafeMutablePointer<SFBoolean>(OpaquePointer(baseAddress))
            SFAlbumGetCaretEdges(sfAlbum, unsafeStops, unsafeEdges)

            return true
        }

        if loaded == nil {
            SFAlbumGetCaretEdges(sfAlbum, nil, unsafeEdges)
        }

        let edgesBuffer = UnsafeBufferPointer(start: unsafeEdges, count: edgeCount)
        let edgesArray = edgesBuffer.map { CGFloat($0) * sizeByEm }

        return edgesArray
    }

    func setup(string: String, codeUnitRange: Range<Int>, isBackward: Bool, sizeByEm: CGFloat) {
        self.string = string
        self.codeUnitRange = codeUnitRange
        self.isBackward = isBackward
        self.sizeByEm = sizeByEm
    }
}

// MARK: - Collections

extension ShapingResult {
    /// A collection of the glyph ids in a shaping result.
    public struct GlyphIDs: RandomAccessCollection {
        private let owner: ShapingResult
        private let pointer: UnsafePointer<GlyphID>!

        init(_ owner: ShapingResult) {
            self.owner = owner
            self.pointer = SFAlbumGetGlyphIDsPtr(owner.sfAlbum)
            self.count = owner.glyphCount
        }

        /// The number of elements in the collection.
        public let count: Int

        /// The index to the first element.
        public var startIndex: Int {
            return 0
        }

        /// The index after the last element.
        public var endIndex: Int {
            return count
        }

        /// Accesses the glyph id at the specified position.
        ///
        /// - Parameter index: The position of the element to access. `index` must be greater than or equal to
        ///                    `startIndex` and less than `endIndex`.
        public subscript(index: Int) -> GlyphID {
            precondition(index >= 0 && index < count, String.indexOutOfRange)

            return pointer[index]
        }
    }

    /// A collection of the glyph offsets in a shaping result.
    public struct GlyphOffsets: RandomAccessCollection {
        private let owner: ShapingResult
        private let pointer: UnsafePointer<SFPoint>!

        init(_ owner: ShapingResult) {
            self.owner = owner
            self.pointer = SFAlbumGetGlyphOffsetsPtr(owner.sfAlbum)
            self.count = owner.glyphCount
        }

        /// The number of elements in the collection.
        public let count: Int

        /// The index to the first element.
        public var startIndex: Int {
            return 0
        }

        /// The index after the last element.
        public var endIndex: Int {
            return count
        }

        /// Accesses the glyph offset at the specified position.
        ///
        /// - Parameter index: The position of the element to access. `index` must be greater than or equal to
        ///                    `startIndex` and less than `endIndex`.
        public subscript(index: Int) -> CGPoint {
            precondition(index >= 0 && index < count, String.indexOutOfRange)

            return CGPoint(x: CGFloat(pointer[index].x) * owner.sizeByEm,
                           y: CGFloat(pointer[index].y) * owner.sizeByEm)
        }
    }

    /// A collection of the glyph advances in a shaping result.
    public struct GlyphAdvances: RandomAccessCollection {
        private let owner: ShapingResult
        private let pointer: UnsafePointer<SFInt32>!

        init(_ owner: ShapingResult) {
            self.owner = owner
            self.pointer = SFAlbumGetGlyphAdvancesPtr(owner.sfAlbum)
            self.count = owner.glyphCount
        }

        /// The number of elements in the collection.
        public let count: Int

        /// The index to the first element.
        public var startIndex: Int {
            return 0
        }

        /// The index after the last element.
        public var endIndex: Int {
            return count
        }

        /// Accesses the glyph advance at the specified position.
        ///
        /// - Parameter index: The position of the element to access. `index` must be greater than or equal to
        ///                    `startIndex` and less than `endIndex`.
        public subscript(index: Int) -> CGFloat {
            precondition(index >= 0 && index < count, String.indexOutOfRange)

            return CGFloat(pointer[index]) * owner.sizeByEm
        }
    }

    /// A collection of the cluster map in a shaping result, represented by UTF-16 code unit indices.
    public struct ClusterMap: RandomAccessCollection {
        private let owner: ShapingResult
        private let pointer: UnsafePointer<SFUInteger>!

        init(_ owner: ShapingResult) {
            self.owner = owner
            self.pointer = SFAlbumGetCodeunitToGlyphMapPtr(owner.sfAlbum)
            self.count = owner.codeUnitRange.count
        }

        /// The number of elements in the collection.
        public let count: Int

        /// The index to the first element.
        public var startIndex: Int {
            return 0
        }

        /// The index after the last element.
        public var endIndex: Int {
            return count
        }

        /// Accesses the glyph index at the specified position.
        ///
        /// - Parameter index: The position of the element to access. `index` must be greater than or equal to
        ///                    `startIndex` and less than `endIndex`.
        public subscript(index: Int) -> Int {
            precondition(index >= 0 && index < count, String.indexOutOfRange)

            return Int(pointer[index])
        }
    }
}
